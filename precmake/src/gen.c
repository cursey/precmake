#include <stdlib.h>
#include "gen.h"

typedef struct GenContext GenContext;
struct GenContext
{
    Arena *arena;
    StrList out;
    int indent_level;
};

static void gen_str(GenContext *ctx, Str str)
{
    str_list_push(ctx->arena, &ctx->out, str);
}

static void gen_str_indented(GenContext *ctx, Str str)
{
    for (int i = 0; i < ctx->indent_level; i++)
    {
        str_list_push(ctx->arena, &ctx->out, str_lit("    "));
    }
    str_list_push(ctx->arena, &ctx->out, str);
}

static void gen_prelude(GenContext *ctx)
{
    gen_str_indented(ctx, str_lit("# Generated by precmake\n"));
    gen_str_indented(ctx, str_lit("# Do not edit\n"));
    gen_str_indented(ctx, str_lit("cmake_minimum_required(VERSION 3.25)\n"));
    gen_str_indented(ctx, str_lit("file(DOWNLOAD\n"));
    ++ctx->indent_level;
    gen_str_indented(ctx, str_lit("https://github.com/cpm-cmake/CPM.cmake/releases/download/v0.40.2/CPM.cmake\n"));
    gen_str_indented(ctx, str_lit("${CMAKE_CURRENT_BINARY_DIR}/cmake/CPM.cmake\n"));
    gen_str_indented(ctx,
                     str_lit("EXPECTED_HASH SHA256=c8cdc32c03816538ce22781ed72964dc864b2a34a310d3b7104812a5ca2d835d"));
    --ctx->indent_level;
    gen_str_indented(ctx, str_lit(")\n"));
    gen_str_indented(ctx, str_lit("include(${CMAKE_CURRENT_BINARY_DIR}/cmake/CPM.cmake)\n"));
}

//
// Condition
//

static void gen_condition_begin(GenContext *ctx, ConditionList *conditions)
{
    // If the condition list is empty, we don't need to do anything.
    if (conditions->count == 0)
    {
        return;
    }

    // Start the condition block.
    gen_str_indented(ctx, str_lit("if("));

    // Loop through each condition, anding them together.
    bool single_condition = conditions->count == 1;
    for (Condition *condition = conditions->head; condition != 0; condition = condition->next)
    {
        if (!single_condition)
        {
            gen_str(ctx, str_lit("("));
        }
        for (StrNode *expression = condition->expressions.head; expression; expression = expression->next)
        {
            gen_str(ctx, push_strf(ctx->arena, "%.*s", str_varg(expression->str)));
            if (expression->next)
            {
                gen_str(ctx, str_lit(" AND "));
            }
        }
        if (!single_condition)
        {
            gen_str(ctx, str_lit(")"));
        }
        if (condition->next)
        {
            gen_str(ctx, str_lit(" AND "));
        }
    }

    // End the condition block.
    gen_str(ctx, str_lit(")\n"));
    ++ctx->indent_level;
}

static void gen_condition_end(GenContext *ctx, ConditionList *conditions)
{
    // If the condition list is empty, we don't need to do anything.
    if (conditions->count == 0)
    {
        return;
    }

    // End the condition block.
    --ctx->indent_level;
    gen_str_indented(ctx, str_lit("endif()\n"));
}

//
// Property
//

static Str property_visibility(Property *property)
{
    switch (property->visibility)
    {
    case PropertyVisibility_None:
        return str_lit("");

    case PropertyVisibility_Public:
        return str_lit("PUBLIC");

    case PropertyVisibility_Private:
        return str_lit("PRIVATE");

    case PropertyVisibility_Interface:
        return str_lit("INTERFACE");

    default:
        abort();
    }
}

static Str property_generator(Property *property)
{
    switch (property->type)
    {
    case PropertyType_LinkLibraries:
        return str_lit("target_link_libraries");

    case PropertyType_IncludeDirectories:
        return str_lit("target_include_directories");

    case PropertyType_CompileDefinitions:
        return str_lit("target_compile_definitions");

    case PropertyType_ManuallyAddedDependencies:
        return str_lit("add_dependencies");

    default:
        abort();
    }
}

static void gen_property(GenContext *ctx, Property *property)
{
    gen_condition_begin(ctx, &property->conditions);
    Str generator = property_generator(property);
    Str visibility = property_visibility(property);
    gen_str_indented(ctx, push_strf(ctx->arena, "%.*s(%.*s %.*s\n", str_varg(generator),
                                    str_varg(property->target->name), str_varg(visibility)));
    ++ctx->indent_level;
    for (StrNode *library = property->values.head; library; library = library->next)
    {
        gen_str_indented(ctx, push_strf(ctx->arena, "%.*s\n", str_varg(library->str)));
    }
    --ctx->indent_level;
    gen_str_indented(ctx, str_lit(")\n"));
    gen_condition_end(ctx, &property->conditions);
}

//
// Target
//

static Str target_generator(Target *target)
{
    switch (target->type)
    {
    case TargetType_Executable:
        return str_lit("add_executable(");

    case TargetType_StaticLibrary:
        return str_lit("add_library(");

    case TargetType_SharedLibrary:
        return str_lit("add_library(");

    case TargetType_Custom:
        return str_lit("add_custom_target(");

    default:
        abort();
    }
}

static Str target_generator_ext(Target *target)
{
    switch (target->type)
    {
    case TargetType_Executable:
        return str_lit("");

    case TargetType_StaticLibrary:
        return str_lit("STATIC");

    case TargetType_SharedLibrary:
        return str_lit("SHARED");

    case TargetType_Custom:
        return str_lit("DEPENDS");

    default:
        abort();
    }
}

static void gen_target(GenContext *ctx, Target *target)
{
    Str generator = target_generator(target);
    Str generator_ext = target_generator_ext(target);
    gen_str_indented(ctx, push_strf(ctx->arena, "%.*s %.*s %.*s\n", str_varg(generator), str_varg(target->name),
                                    str_varg(generator_ext)));
    ++ctx->indent_level;
    for (StrNode *source = target->sources.head; source; source = source->next)
    {
        gen_str_indented(ctx, push_strf(ctx->arena, "%.*s\n", str_varg(source->str)));
    }
    --ctx->indent_level;
    gen_str_indented(ctx, str_lit(")\n"));
    for (Property *property = target->properties.head; property; property = property->next)
    {
        gen_property(ctx, property);
    }
}

//
// Package
//

static void gen_package(GenContext *ctx, Package *package)
{
    gen_str_indented(ctx, str_lit("CPMAddPackage(\n"));
    ++ctx->indent_level;
    gen_str_indented(ctx, push_strf(ctx->arena, "NAME %.*s\n", str_varg(package->name)));
    gen_str_indented(ctx, push_strf(ctx->arena, "GIT_REPOSITORY %.*s\n", str_varg(package->url)));
    gen_str_indented(ctx, push_strf(ctx->arena, "GIT_TAG %.*s\n", str_varg(package->tag)));
    if (package->download_only)
    {
        gen_str_indented(ctx, str_lit("DOWNLOAD_ONLY TRUE\n"));
    }
    if (package->options.node_count > 0)
    {
        gen_str_indented(ctx, str_lit("OPTIONS\n"));
        ++ctx->indent_level;
        for (StrNode *option = package->options.head; option; option = option->next)
        {
            gen_str_indented(ctx, push_strf(ctx->arena, "\"%.*s\"\n", str_varg(option->str)));
        }
        --ctx->indent_level;
    }
    --ctx->indent_level;
    gen_str_indented(ctx, str_lit(")\n"));
}

//
// ListOp
//

static Str list_op_str(ListOp *operation)
{
    switch (operation->type)
    {
    case ListOpType_RemoveItem:
        return str_lit("LIST(REMOVE_ITEM");

    case ListOpType_FilterExclude:
        return str_lit("LIST(FILTER");

    default:
        abort();
    }
}

static Str list_op_ext(ListOp *operation)
{
    switch (operation->type)
    {
    case ListOpType_RemoveItem:
        return str_lit("");

    case ListOpType_FilterExclude:
        return str_lit("EXCLUDE REGEX");

    default:
        abort();
    }
}

static void gen_list_op(GenContext *ctx, Glob *glob, ListOp *exclusion)
{
    gen_condition_begin(ctx, &exclusion->conditions);
    Str op_str = list_op_str(exclusion);
    Str op_ext = list_op_ext(exclusion);
    gen_str_indented(
        ctx, push_strf(ctx->arena, "%.*s %.*s %.*s\n", str_varg(op_str), str_varg(glob->name), str_varg(op_ext)));
    ++ctx->indent_level;
    for (StrNode *item = exclusion->items.head; item; item = item->next)
    {
        gen_str_indented(ctx, push_strf(ctx->arena, "%.*s\n", str_varg(item->str)));
    }
    --ctx->indent_level;
    gen_str_indented(ctx, str_lit(")\n"));
    gen_condition_end(ctx, &exclusion->conditions);
}

//
// Glob
//

static void gen_glob(GenContext *ctx, Glob *glob)
{
    Str type = (glob->recursive) ? str_lit("GLOB_RECURSE") : str_lit("GLOB");
    gen_str_indented(ctx, push_strf(ctx->arena, "file(%.*s %.*s %.*s)\n", str_varg(type), str_varg(glob->name),
                                    str_varg(glob->pattern)));
    for (ListOp *operation = glob->operations.head; operation; operation = operation->next)
    {
        gen_list_op(ctx, glob, operation);
    }
}

//
// When
//

void gen_thing(GenContext *ctx, Thing *thing);

static void gen_when(GenContext *ctx, When *when)
{
    gen_condition_begin(ctx, &when->conditions);
    for (Thing *thing = when->things.head; thing; thing = thing->next)
    {
        gen_thing(ctx, thing);
    }
    gen_condition_end(ctx, &when->conditions);
}

//
// CustomCommand
//

static void gen_custom_command(GenContext *ctx, CustomCommand *cmd)
{
    gen_str_indented(ctx, str_lit("add_custom_command(\n"));
    ++ctx->indent_level;
    if (cmd->depends.node_count > 0)
    {
        gen_str_indented(ctx, str_lit("DEPENDS\n"));
        ++ctx->indent_level;
        for (StrNode *depend = cmd->depends.head; depend; depend = depend->next)
        {
            gen_str_indented(ctx, push_strf(ctx->arena, "%.*s\n", str_varg(depend->str)));
        }
        --ctx->indent_level;
    }
    if (cmd->output.node_count > 0)
    {
        gen_str_indented(ctx, str_lit("OUTPUT\n"));
        ++ctx->indent_level;
        for (StrNode *output = cmd->output.head; output; output = output->next)
        {
            gen_str_indented(ctx, push_strf(ctx->arena, "%.*s\n", str_varg(output->str)));
        }
        --ctx->indent_level;
    }
    gen_str_indented(ctx, str_lit("COMMAND\n"));
    ++ctx->indent_level;
    gen_str_indented(ctx, push_strf(ctx->arena, "%.*s\n", str_varg(cmd->command)));
    --ctx->indent_level;
    if (cmd->comment.len > 0)
    {
        gen_str_indented(ctx, str_lit("COMMENT\n"));
        ++ctx->indent_level;
        gen_str_indented(ctx, push_strf(ctx->arena, "\"%.*s\"\n", str_varg(cmd->comment)));
        --ctx->indent_level;
    }
    --ctx->indent_level;
    gen_str_indented(ctx, str_lit(")\n"));
}

//
// Option
//

static void gen_option(GenContext *ctx, Option *opt)
{
    gen_str_indented(ctx, push_strf(ctx->arena, "option(%.*s \"%.*s\" \"%.*s\")\n", str_varg(opt->name),
                                    str_varg(opt->description), str_varg(opt->value)));
}

//
// Thing
//

static void gen_thing(GenContext *ctx, Thing *thing)
{
    gen_condition_begin(ctx, &thing->conditions);
    switch (thing->type)
    {
    case ThingType_Target:
        gen_target(ctx, thing->target);
        break;

    case ThingType_Package:
        gen_package(ctx, thing->package);
        break;

    case ThingType_Glob:
        gen_glob(ctx, thing->glob);
        break;

    case ThingType_When:
        gen_when(ctx, thing->when);
        break;

    case ThingType_CustomCommand:
        gen_custom_command(ctx, thing->custom_command);
        break;

    case ThingType_Option:
        gen_option(ctx, thing->option);
        break;

    default:
        abort();
    }
    gen_condition_end(ctx, &thing->conditions);
}

//
// Project
//

static void gen_project(GenContext *ctx, Project *project)
{
    gen_str_indented(ctx, push_strf(ctx->arena, "project(%.*s)\n", str_varg(project->name)));
    for (Thing *thing = project->things.head; thing; thing = thing->next)
    {
        gen_thing(ctx, thing);
    }
}

Str gen_cmakelists(Arena *arena, Project *project)
{
    GenContext ctx = {0};
    ctx.arena = arena_alloc();
    gen_prelude(&ctx);
    gen_project(&ctx, project);
    Str result = str_list_flatten(arena, &ctx.out);
    arena_release(ctx.arena);
    return result;
}